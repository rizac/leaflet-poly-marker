/** polymarker.min.js (c) Riccardo Zaccarelli */
L.PolyMarker=L.Polygon.extend({options:{marker:"s",radius:10},markers:{s:[45,4],d:[0,4],D:[0,4],p:[18,5],h:[30,6],H:[0,6],"^":[-30,3],v:[-90,3],"<":[60,3],">":[0,3],8:[22.5,8]},initialize:function(t,...n){if(2==n.length){var[a,n]=n;n.marker=a}else n=n[0];L.Util.setOptions(this,n),L.Polygon.prototype.initialize.call(this,[],n),Array.isArray(t)&&(t=L.latLng(t[0],t[1])),this._latlng=t},onRemove:function(){delete this._mapZoom,L.Polygon.prototype.onRemove.call(this)},getCenter:function(){return this._latlng},_project:function(){this._map&&this._map.getZoom()!==this._mapZoom&&(this._mapZoom=this._map.getZoom(),this._setLatLngs(this.computeLatLngs(this._map))),L.Polygon.prototype._project.call(this)},computeLatLngs:function(t){var n=this.options.marker;if(n in this.markers)var[a,o]=this.markers[n];else{if(parseInt(n)!=n)return[];var[a,o]=[0,parseInt(n)]}var[r,e,i,s]=[Math.PI,Math.cos,Math.sin,Math.abs];a=r*a/180;var l=2*r/o,p=new Array(o).fill(0).map((t,n)=>n*l+a),h=size/2,m=this._latlng,g=t.latLngToLayerPoint(m),y=p.map(function(n,a){var[o,r]=[h*e(n),h*i(n)];return t.layerPointToLatLng(new L.Point(g.x+o,g.y-r))});if("d"==n){var c=s(y[0].lng-y[2].lng)/4;y[0].lng-=c,y[2].lng+=c}return y}}),L.polyMarker=function(t,...n){return new L.PolyMarker(t,...n)};