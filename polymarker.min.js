/** polymarker.min.js (c) Riccardo Zaccarelli */
L.PolyMarker=L.Polygon.extend({options:{marker:"s",radius:10},markers:{s:[45,4],d:[0,4],D:[0,4],p:[18,5],h:[30,6],H:[0,6],"^":[-30,3],v:[-90,3],"<":[60,3],">":[0,3],8:[22.5,8]},initialize:function(t,...n){if(2==n.length){var[o,n]=n;n.marker=o}else n=n[0];L.Util.setOptions(this,n),L.Polygon.prototype.initialize.call(this,[],n),Array.isArray(t)&&(t=L.latLng(t[0],t[1])),this._latlng=t},onRemove:function(){delete this._mapZoom,L.Polygon.prototype.onRemove.call(this)},getCenter:function(){return this._latlng},_project:function(){this._map&&this._map.getZoom()!==this._mapZoom&&(this._mapZoom=this._map.getZoom(),this._setLatLngs(this.computeLatLngs(this._map))),L.Polygon.prototype._project.call(this)},computeLatLngs:function(t){var n=this.options.marker;if(n in this.markers)var[o,a]=this.markers[n];else{if(parseInt(n)!=n)return[];var[o,a]=[0,parseInt(n)]}var[r,i,e,s]=[Math.PI,Math.cos,Math.sin,Math.abs];o=r*o/180;var l=2*r/a,p=new Array(a).fill(0).map((t,n)=>n*l+o),h=this._latlng,m=t.latLngToLayerPoint(h),g=this.options.radius,u=p.map(function(n,o){var[a,r]=[g*i(n),g*e(n)];return t.layerPointToLatLng(new L.Point(m.x+a,m.y-r))});if("d"==n){var y=s(u[0].lng-u[2].lng)/4;u[0].lng-=y,u[2].lng+=y}return u}}),L.polyMarker=function(t,...n){return new L.PolyMarker(t,...n)};